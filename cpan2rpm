#!/usr/bin/perl

#
#   CPAN module RPM maker
#

use vars qw($VERSION $VX);
$VERSION = 2.007;

# --- prologue ----------------------------------------------------------------

use strict;
use Getopt::Long;
use Sys::Hostname;
use Config;
use ExtUtils::MakeMaker;

# --- main() ------------------------------------------------------------------

init();            # initialise stuff
get_meta();        # get metadata from tarball
mk_spec();         # create a custom spec file
mk_rpm();          # build the RPM
inst_rpm();        # install it if requested

# --- support functionality ---------------------------------------------------

my ($TMPDIR, $TMPBUILD, %RPMDIR, $CWD, %MAC, %info);

sub init {
    $|++;    # good for system()

    $TMPDIR  = "/tmp/cpan2rpm";
    $CWD     = qx/pwd/; chomp($CWD);
    mkdir $TMPDIR, 01777;
    -d $TMPDIR or die "$TMPDIR: $!";

    my $arch = $1 if $Config{config_args} =~ /-march=(\S+)/;
    $arch ||= "unknown";

    # package info defaults
    %info =
        (    url              => "http://www.cpan.org"
        ,    packager         => "Arix International <cpan2rpm\@arix.com>"
        ,    group            => "Applications/CPAN"
        ,    license          => "Artistic"
        ,    release          => 1
        ,    buildarch        => $arch
        ,    buildroot        => "%{_tmppath}/%{name}-%{version}-%(id -u -n)"
        ,    description      => "None."
        );

    # syntax descriptions
    my %desc =
        (    "pkgname=s"        => "RPM package name"
        ,    "version=s"        => "override the CPAN version number"
        ,    "summary=s"        => "package summary"
        ,    "author=s"         => "author information"
        ,    "url=s"            => "home URL"
        ,    "packager=s"       => "packager identification"
        ,    "group=s"          => "RPM group"
        ,    "license=s"        => "licensing information"
        ,    "release=i"        => "RPM relase number"
        ,    "distribution=s"   => "Linux distribution"
        ,    "buildarch=s"      => "package architecture"
        ,    "buildroot=s"      => "root directory to use for build"
        ,    "requires=s"       => "packages required for installation"
        ,    "provides=s"       => "modules provided by the package"
        ,    "no-requires=s"    => "suppresses generation of a set of reqs"
        ,    "req-scan-all"     => "scan all files in a tarball for reqs"
        ,    "find-provides=s"  => "instructs us to use a given filter"
        ,    "find-requires=s"  => "(see man page for further details)"
        ,    "spec-only"        => "only displays spec file to stdout"
        ,    "make-maker=s"     => "arguments for makefile creation"
        ,    "make=s"           => "arguments passed to make"
        ,    "make-no-test"     => "suppress running test suite"
        ,    "make-install=s"   => "arguments for make install"
        ,    "no-clean"         => "suppress --clean"
        ,    "shadow-pure"      => "override existing pure perl module"
        ,    "patch|p=s@"       => "specifies (multiple) patches to apply"
        ,    "install|i"        => "install package when done"
        ,    "description=s"    => "package description"
        ,    "nopkgprfx"        => "suppresses package name prefix"
        ,    "force"            => "forces all operations"
        ,    "debug:i"          => "produce debugging output"
        ,    "help|h"           => "this help screen"
        ,    "V"                => "cpan2rpm version"
        );

    # get user options
    my %opts = ();
    my $ret = GetOptions(\%opts, keys %desc);

	$VX++, exit if $opts{V};

    print "\n-- cpan2rpm - Ver: $::VERSION --\n\n" if !$opts{"spec-only"};
    syntax(\%desc) if defined $opts{help} || !$ret;

    # override defaults with user options
    %info = (%info, %opts);

    # set requirements patch override

    $ENV{CPAN2RPM_REQ_ALL} = $info{"req-scan-all"};

    # get module name
    $info{module} = shift @ARGV
        || syntax(\%desc, "No module or file specified!");

    if ($<) { # Non superuser
        # Make sure .rpmmacros is there
        my $user_macros = "$ENV{HOME}/.rpmmacros";
        if (!-e $user_macros) {
            system( qq{
              mkdir ~/redhat ;
              cd ~/redhat ;
              mkdir BUILD RPMS SOURCES SPECS SRPMS ;
              echo %_topdir ~/redhat >> $user_macros ;
              });
            }
        if ($info{install}) {
            print "\n-- NON ROOT install requires sudo rpm privileges --\n";
            if (system("sudo rpm -v")) {
                print "You can configure sudo with the following command:\n\n";
                print "  echo ".getlogin()." ALL=/bin/rpm >> /etc/sudoers\n\n";
                die "sudo failed: CANNOT USE --install OPTION!  Stopped";
                }
            else {
                print "\n-- NON ROOT sudo precheck successful.\n";
                }
            }
        }
    $RPMDIR{SOURCES} = getrpm_macdef("_sourcedir");
    $RPMDIR{RPMS} = getrpm_macdef("_rpmdir");
    $RPMDIR{SRPMS} = getrpm_macdef("_srcrpmdir");
    $RPMDIR{SPECS} = getrpm_macdef("_specdir");
    $RPMDIR{ARCH} = getrpm_macdef("_arch");

    searchcpan();

    if (isurl($info{module})) {
        #
        #    a url was passed
        #

        get_url($RPMDIR{SOURCES}, $info{module});
		
        $info{module} =~ s|.*/||;     # remove path
        $info{module} =~ s/-(\d+\.?\d*)\.(tar\.g?z|tgz).*//;
        }

    elsif (istarball($info{module}, 1)) {
        #
        #    argument passed is a local file name
        #

        my ($d, $f) = $info{module} =~ m|(.*?)/?([^/]*)$|;

        system("cp -u $info{module} $RPMDIR{SOURCES}") == 0
            || die "Unable to copy tarball: $!"
            unless finode($info{module}) eq finode("$RPMDIR{SOURCES}/$f")
            ;

        $info{module} =~ s|.*/||;     # remove path
        $info{tarball} = $info{module};
        $info{module} =~ s/-(\d+\.?\d*)\.(tar\.g?z|tgz)$//;
        $info{module} =~ s/-/::/g;
        }

    else {
        #
        #    assume argument passed is a Perl module name
        #

        get_mod();
        }
    }

END {
    chdir $CWD;
    qx/rm -rf $TMPBUILD/ if $TMPBUILD && !$info{debug};
	print("$VERSION\n") if $VX;
	return if $info{"spec-only"} || $VX;
    print "-- Done --\n";
    }

#
#    get metadata from tarball's MakeMaker file
#

sub get_meta {
    my $f = shift || "$RPMDIR{SOURCES}/$info{tarball}";

    my @ls;
    ($info{tardir}, @ls) = tarls($f);
    $info{tardir} = "%{pkgname}-%{version}"
        if $info{tardir} eq "$info{module}-$info{version}";
    $info{create} = "-c" if $info{tardir} =~ s/\+$//;

    #    create file-list for spec's %doc section

    @ls = map(m|[^/]*/(.*)|, @ls);    # strip leading dir
    my $re = "(readme|changes|todo|license|install|\.txt|\.html)";
    $info{doc} = join(" ", grep(/$re/i, @ls));
    $info{doc} = "%doc $info{doc}" if $info{doc};

    #    extract tarball

    print "Tarball extraction: [$f]\n" if !$info{"spec-only"};
    chdir($TMPBUILD = untar($f));

    #    execute modified Makefile.PL

    print "Metadata retrieval\n" if !$info{"spec-only"};

    my %meta;
    # grap parameters to WriteMakefile()
    sub MyWriteMakefile {
        %meta = @_;
        };

    local $_ = qq/package make; no strict; local (*STDOUT, *STDERR) = (); /;
    $_ .= qq/\$ARGV[0] = q{$info{"make-maker"}}; / if $info{"make-maker"};
    $_ .= readfile("Makefile.PL");
    s/(qw\(.*)WriteMakefile(.*\))/$1$2/g;
    s/(ExtUtils::MakeMaker::)?WriteMakefile/::MyWriteMakefile/g;
    s/(\W)exit(\W)/${1}die$2/g;
    eval() || warn $!;
    $info{author} ||= $meta{AUTHOR};

    #    figure out package name

    $info{pkgname} ||= $meta{DISTNAME} || $meta{NAME} || $info{module};
    $info{pkgname} =~ s/::/-/g;
    die "No package name available.  Stopped"
        unless $info{pkgname};

    #    get module description info

    my $from = $meta{ABSTRACT_FROM} || $meta{VERSION_FROM};
    ($from = "$info{pkname}.pm") =~ s/.*:// unless $from;
    $from = readfile($from);

    if (!$meta{ABSTRACT} && $from) {
        local $_ = $from;
        ($meta{ABSTRACT}) = /=head\d\s+NAME.*?-\s*(.*?)$/ism;
        ($meta{DESCRIPTION}) = /=head\d\s+SYNOPSIS\s+(.*?)=head/ism;
        $meta{DESCRIPTION} =~ s/E<lt>/</ig;
        $meta{DESCRIPTION} =~ s/E<gt>/>/ig;
        }

    if (!$info{author} && $from) {
        local $_ = $from;
        ($info{author}) = /=head\d\s+AUTHOR\s+(.*)/i;
        $info{author} =~ s/E<lt>/</ig;
        $info{author} =~ s/E<gt>/>/ig;
        }

    if (!$info{author} &&
        isurl($info{source}) &&
        $info{source} =~ m%author.*/([A-Z\-]+)/[^/]+$%) {
        # Extract generic author from url
        $info{author} = (lc $1).'@cpan.org';
        }

    die "No author information found and none supplied.  Stopped"
        unless $info{author};

    #    extract version from tarball name

    unless ($info{version}) {
        $info{tarball} =~ /-(\d+.*)\.(tar\.g?z|tgz)$/;
        $info{version} = $1
            || die "Could not ascertain version and none passed!";
        }

    #    assemble other info

    $info{spec} = "$RPMDIR{SPECS}/$info{pkgname}.spec";
    $info{summary} = "$info{pkgname} - " . ($meta{ABSTRACT} || "Perl module");
    $info{description} = $meta{DESCRIPTION} if $meta{DESCRIPTION};
    $info{source} ||= $info{tarball};
    $info{source} =~ s/$info{pkgname}/%{pkgname}/;
    $info{source} =~ s/$info{version}/%{version}/;
    $info{distribution} = getrpm_macdef("distribution") || distro();
    $info{changelog} = changelog();

    $info{requires} &&= "Requires: $info{requires}";
    $info{provides} &&= "Provides: $info{provides}";

    $info{"find-provides"}
        &&= qq/%define __find_provides $info{"find-provides"}/;
    $info{"find-requires"}
        &&= qq/%define __find_requires $info{"find-requires"}/;
    if ($info{"no-requires"}) {
        my $noreqs = "";
        $noreqs .= qq/-e '$_' / for split /\s*,\s*/, $info{"no-requires"};
        $info{"no-requires"}{"define"}
            = "%define custom_find_req %{_tmppath}/%{NVR}-find-requires";
        $info{"find-requires"} = "%define __find_requires %{custom_find_req}";
        local $_ = qq[cat <<EOF > %{custom_find_req}
            #!/bin/sh
            /usr/lib/rpm/find-requires |grep -v $noreqs
            EOF
            chmod 755 %{custom_find_req}
            ];
        s/^\s+//mg;
        $info{"no-requires"}{"install"} = $_;
        $info{"no-requires"}{"clean"} = "rm -f %{custom_find_req}";
        }

    # generate patch info
    for my $i (0 .. $#{$info{patch}}) {
        $info{"patch-files"} .= "Patch$i: $info{patch}->[$i]\n";
        $info{"patch-apply"} .= "%patch$i -p1\n";
        # put patches in RPM dir if needed
        system("cp -u $info{patch}->[$i] $RPMDIR{SOURCES}") == 0
            || die "Unable to copy patch: $!"
        }

    # return to user's directory

    chdir $CWD;
    }

#
#    generate s spec file
#

sub mk_spec {
    print "-- Generating spec file --\n" if !$info{"spec-only"};

    my $pkgname = $info{pkgname};
    $pkgname = "perl-" . $pkgname unless $info{nopkgprfx};
    $info{description} =~ s/\s+$//;
    $info{maketest} = "%{__make} test" unless $info{"make-no-test"};

    if ($ExtUtils::MakeMaker::VERSION =~ /5.9[1-6]|6.0[0-5]/) {
        # Known bug in 5.91_01 - 6.05:
        # Must do "perl Makefile.PL PREFIX=foo"
        # since it is ignored on the "make install" line.
        $info{"make-maker"} .= ' PREFIX=%{buildroot}%{_prefix}'
            unless $info{"make-maker"} =~ /PREFIX=/;
        }
    if ($info{"shadow-pure"}) {
        $info{"make-maker"} .= q{
            # Force pure perl installs into first @INC slot
            %{__perl} -p -i -e 's,(INSTALL[PVS]\w+LIB =).*,$1 \$(INSTALLARCHLIB),' Makefile;

            # Avoid man page conflicts with default
            %{__perl} -p -i -e 's,(MAN3EXT =).*,$1 3,' Makefile;
            };
        }

    local $_ = <<ZZ;
        #
        #    cpan2rpm - This spec file was automatically generated.
        #    For further information please refer to: http://perl.arix.com/
        #

        %define pkgname    $info{pkgname}
        %define filelist %{pkgname}-%{version}-filelist
        %define NVR %{pkgname}-%{version}-%{release}
        $info{"no-requires"}{"define"}

        Summary:       $info{summary}
        Name:          $pkgname
        Version:       $info{version}
        Release:       $info{release}
        Group:         $info{group}
        Distribution:  $info{distribution}
        Vendor:        $info{author}
        Packager:      $info{packager}
        License:       $info{license}
        Url:           $info{url}
        BuildRoot:     $info{buildroot}
        BuildArch:     $info{buildarch}
        Source:        $info{source}

        $info{"patch-files"}
        $info{requires}
        $info{provides}

        %description
        $info{description}

        #
        # This package was automatically generated with the cpan2rpm
        # utility.  To get this software or for more information
        # please visit: http://perl.arix.com/
        #
        $info{"find-provides"}
        $info{"find-requires"}

        %prep
        %setup -q -n $info{tardir} $info{create}
        $info{"patch-apply"}

        %build
        CFLAGS="\$RPM_OPT_FLAGS"
        %{__perl} Makefile.PL $info{"make-maker"}
        %{__make} $info{"make"}
        $info{maketest}

        %install
        [ "%{buildroot}" != "/" ] && rm -rf %{buildroot}
        $info{"no-requires"}{"install"}

        %{makeinstall} PREFIX=%{buildroot}%{_prefix} $info{"make-install"}

        [ -x /usr/lib/rpm/brp-compress ] && /usr/lib/rpm/brp-compress

        find %{buildroot} -name "perllocal.pod" \\
            -o -name ".packlist"                    \\
            -o -name "*.bs"                         \\
            |xargs -i rm -f {}

        find %{buildroot}%{_prefix} -type d -depth -exec rmdir {} \\; 2>/dev/null

        %clean
        [ "%{buildroot}" != "/" ] && rm -rf %{buildroot}
        $info{"no-requires"}{"clean"}

        %files
        %defattr(-,root,root)
        $info{doc}
        %{_prefix}

        %changelog
        * $info{changelog}
        - Initial build.
ZZ
    s/^\s+//gm;    # clean up

    print(), exit if $info{"spec-only"};
    writefile($info{spec});
    }

#
#    build the package
#

sub mk_rpm {
    my $pkgname = $info{pkgname};
    $pkgname = "perl-" . $pkgname unless $info{nopkgprfx};
    $info{rpm} = sprintf("%s/%s-%s-%s.%s.rpm"
        , "$RPMDIR{RPMS}/$info{buildarch}"
        , $pkgname
        , $info{version}
        , $info{release}
        , $info{buildarch}
        );

    return if -r $info{rpm} && !$info{force};

    print "-- Generating package --\n";

    my $ret = 0;

    system("rpmbuild -bp $info{spec}");
    warn("RPM test unpacking failed!") if $ret = $? >> 8;

    if ($ret == 0) {
        my $clean = $info{"no-clean"} ? "" : "--clean";
        system("rpmbuild -ba $clean $info{spec}");
        warn("RPM build failed!") if $ret = $? >> 8;
        }

    return $ret;
    }

#
#    if requested, will also install the resulting RPM
#

sub inst_rpm {
    return unless $info{install};

    print "-- Installing package --\n";
    my $install_command = "";
    $install_command = "sudo " if $<;
    $install_command .= "rpm -Uvh $info{rpm}";
    system($install_command);
    return $? >> 8;
    }

# --- module retrieval functions ----------------------------------------------

#
#    Walks search.cpan.org for the latest uploaded distribution.
#    Uses LWP instead of CPAN to determine the tarball.
#

sub searchcpan {
    # Abort unless it smells like a CPAN module
    return unless $info{module} =~ /^[\w:\-]+$/;
    print "-- Searching CPAN for module $info{module} --\n" if !$info{"spec-only"};
    # XXX - This algorithm may change as the
    # search.cpan.org web site output changes.
    $@ = ""; eval "use HTTP::Request::Common; use LWP::UserAgent;";
    if ($@) {
        # Could not load libwww-perl
        print "-- WARNING: libwww-perl module not found!\n";
        print "-- Install libwww-perl to avoid this warning.\n";
        print "-- One of the following options may help:\n";
        print "--   1) Try http://www.rpmfind.net/linux/rpm2html/search.php?query=perl-libwww-perl\n";
        print "--   2) Specify the full URL of the tarball manually.\n";
        print "--   3) Download tarball and specify file on commandline.\n";
        print "--   4) Configure CPAN:  perl -MCPAN -eshell\n";
        print "--   5) cpan2rpm --install libwww-perl\n";
        }
    else {
        my $dist = $info{module};
        $dist =~ s/::/-/g;
        my $dist_url = "http://search.cpan.org/dist/$dist/";
        my $ua = new LWP::UserAgent;
        my $response = $ua->request(GET($dist_url));
        my $page = $response->content;
        if ($page && $page =~
            m%\<a[^<>]*       # Begin Anchor tag
            href\s*=\s*       # href parameter
            (['"]?)           # Maybe quote
            ([^<>\s"']*)      # Extract link as $2
            \1                # Maybe quote
            [^<>]*\>          # End Anchor tag
            \s*Download       # of the "Download" link
            %ix               # case insensitive HTML
            ) {
            $info{module} = URI->new_abs($2, $response->base)->as_string;
            print "-- Found URL $info{module} --\n" if !$info{"spec-only"};
            }
        }
    }

#
#    grabs the module from CPAN and places in the SOURCES directory
#    ACHTUNG: at present, only the latest version of the module
#    can be retrieved.  For building earlier versions, retrieve the
#    tarball manually.
#

sub get_mod {
    print "-- Retrieving module from CPAN --\n";
    require  CPAN;
    import   CPAN 0.59;

    my $m = CPAN::Shell->expand("Module", $info{module})
        || die "Module not found on CPAN!";

    my $a = CPAN::Shell->expand("Author", $m->{RO}->{CPAN_USERID});
    $info{author} ||= "$a->{RO}->{FULLNAME} <$a->{RO}->{EMAIL}>";

    my $f = $m->{RO}->{CPAN_FILE};
    $info{source} = sprintf("%s/authors/id/%s"
        , "http://www.cpan.org"
        , $f
        );

    my $tarball = $f; $tarball =~ s|.*/||;
    $info{tarball} = $tarball;

    # bail if tarball already there (unless we're being --force'd)
    return if -r "$RPMDIR{SOURCES}/$tarball"
        && ! defined $info{force}
        ;

    get($f);

    my $ff = sprintf("%s/authors/id/%s"
        , $CPAN::Config->{'keep_source_where'}
        , $f
        );

    system("cp $ff $RPMDIR{SOURCES}") if -r $ff;
    }

# --- RPM macro functions -----------------------------------------------------

sub getrpm_init {
    return if %MAC;

    my @f = (
          "/usr/lib/rpm/macros"        # orginal definitions
        , "/etc/rpm/macros"            # site-wide overrides
        , "$ENV{HOME}/.rpmmacros"      # user-specific overrides
        );

    for (@f) {
        %MAC = (%MAC, getrpm_macros()) if -r;
        }
    }

#
#    get an RPM macro definition
#

sub getrpm_macdef($) {
    my $key = shift;

    getrpm_init();
    1 while $MAC{$key} =~ s/%{([^}]+)}/$MAC{$1}/;
    return $MAC{$key};
    }

#
#    retrieves macro definitions from a file
#

sub getrpm_macros {
    local $_ = shift || $_;
    open(_) || die $!;
    my %ret = ();
    for (<_>) {
        next unless s/^%//;
        split;
        $ret{$_[0]} = $_[1];
        }
    close(_);
    return %ret;
    }

# --- tar handling functions --------------------------------------------------

#
#    determines whether given filename represents a tarball
#    optionally dies it file doesn't exist or is not readable
#

sub istarball {
    my ($fn, $fschk) = @_;
    my $is = $fn =~ /\.(tar\.g?z|tgz)$/i;
    return $is unless $fschk && $is;
    -r $fn || die "tarball: $!";
    }

#
#    returns the root dir in a tarball (without trailing /)
#    followed by a listing of all files in the directory
#

sub tarls {
    my $f = shift || $_;

    my ($d, @f);
    for (qx/tar -tzvf $f/) {
        split; local $_ = $_[5];
        $_[0] =~ /^d/ && ($d ||= $_) || (push @f, $_);
        }

    for (@f) {                       # look in file listing
        last if $d;                  # never mind if dir found
        $d = $_ if s|/.*||;          # strip dir from filename
        }

    if (!$d) {                       # if still no subdir found
        local $_ = $f;               # assume tardir
        s|.*/||;                     # without path
        s/\.(tar\.g?z|tgz)$//i;      # or extension
        $d = "$_+";                  # and indicate we made it up
        }

    $d =~ s|^\.+/||;                 # root = ./MyDir/
    $d =~ s|/.*||;                   # make sure subdir found is top level
    wantarray() ? ($d, @f) : $d;     # context aware
    }

#
#    extracts a file from a tarball
#

sub tarx($$) {
    my ($tar, $f) = @_;
    local $_ if defined wantarray();
    $_ = qx/tar -xzOf $tar $f/;
    }

#
#    extracts a tarball
#

sub untar($) {
    my ($tar, $dst) = @_;
    $dst ||= $TMPDIR;
    qx/tar -xz --directory $dst -f $tar/;
    return "$TMPDIR/" . tarls($tar);
    }

# --- file handling functions -------------------------------------------------

#
#    returns the contents of a given file or undef if the
#    file does not exist
#

sub readfile {
    local $_ = shift || $_;
    return undef unless -r;

    local $/ = undef;
    open(_) || die "$! [$_].  Stopped ";
    $_ = <_>;
    close(_);
    $_;
    }

#
#    writes a file, from a string
#

sub writefile($@) {
    my $fn = shift;
    local $_ = shift || $_;

    open (FILE, "> $fn") || die "writefile('$fn'): $!. Stopped";
    binmode(FILE);
    print FILE;
    close(FILE);
    $fn;
    }

#    0: dev, 1: inode, the combination guarantees
#    a unique file in a filesystem

sub finode {
    my $f = shift || $_;
    my @i = stat $f;
    return $i[0] . $i[1];
    }

#    simple test to determine if it's a URL

sub isurl {
    local $_ = shift || $_;
    scalar m#(ht|f)tp://#;
    }

#    Syntax: get_url <directory> [url]

sub get_url($@) {
    my $d = shift;
    my $url = shift || $_;
    $d =~ s|/$||;    # no trailing /s

    $info{source} = $url;
    $url =~ s|.*/||;
    $info{tarball} = $url;

    return if -r "$d/$info{tarball}" && !$info{force};

    print "-- Retrieving URL --\n";
    $@ = ""; eval "use HTTP::Request::Common; use LWP::UserAgent;";
    if (!$@) {
        writefile("$d/$info{tarball}",LWP::UserAgent->new->request(GET($info{source}))->content);
        return;
        }
    $@ = ""; eval "use HTTP::Lite;";
    if (!$@) {
        my $http = new HTTP::Lite;
        $http->request($info{source}) || die "get_url(): $!.  Stopped";
        writefile("$d/$info{tarball}", $http->body());
        return;
        }

    # Could not load libwww-perl
    print "-- WARNING: libwww-perl module not found!\n";
    print "-- Install libwww-perl to avoid this warning: cpan2rpm --install libwww-perl\n";
    print "-- Trying wget...\n";
    if (-e "/usr/bin/wget" && !system("wget --directory-prefix=$d $info{source}")) {
        print "-- Success!\n";
        return;
        }
    print "-- Trying lynx...\n";
    if (-e "/usr/bin/lynx" && !system("lynx -source $info{source} > $info{tarball} && mv $info{tarball} $d/$info{tarball}")) {
        print "-- Success!\n";
        return;
        }
    print "-- Trying links...\n";
    if (-e "/usr/bin/links" && !system("links -source $info{source} > $info{tarball} && mv $info{tarball} $d/$info{tarball}")) {
        print "-- Success!\n";
        return;
        }
    print "-- Trying ncftpget...\n";
    if (-e "/usr/bin/ncftpget") {
        if ($info{source} =~ m%^ftp://%i) {
            if (!system("ncftpget $info{source} && mv $info{tarball} $d/$info{tarball}")) {
                print "-- Success!\n";
                return;
                }
            }
        else {
            print "-- Use the ftp:// url instead of $info{source}\n";
            }
        }
    die "-- External program download failed.  Manual download required.  Stopped";
    }

# --- miscellany --------------------------------------------------------------

#
#    syntax: <scalar> = elem [nth] [regexp] [string = $_]
#

sub elem {
    my $n = shift || 0;
    my $re = shift || '\s+';
    local $_ = shift || $_;
    return (split /$re/)[$n];
    }

#
#    attempts to return the name of the distribution.
#    FIXME: currently only works on RedHat (as far as I know)
#

sub distro {
    for (`cat /etc/issue`) {
        chomp;
        next unless $_;
        return $_;
        }
    }

sub changelog {
    my @dow = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
    my @mon = ("Jan", "Feb", "Mar", "Apr", "May", "Jun"
        , "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
        );

    return sprintf("%s %s %d %d %s"
          , $dow[(localtime)[6]]
        , $mon[(localtime)[4]]
        , (localtime)[3]
        , 1900 + (localtime)[5]
        , sprintf("%s\@%s", (getpwuid($<))[0], hostname())
        );
    }

sub syntax {
    my $args = shift;
    my $warn = shift;

    print "Error:\t$warn\n\n" if $warn;

    local $_ = <<EOF;
    This script automates the creation of RPMs from CPAN modules.
    For further information please see the man page.
EOF
    s/^\s+//mg; print;
    print "\nSyntax: cpan2rpm [options] <module>\n\n";
    print "Where <module> is either the name of a Perl module (e.g.\n";
    print "Proc::Daemon) or of a tarball (e.g. Proc-Daemon-0.02.tar.gz),\n";
    print "and [options] is any of the following:\n\n";
    for (sort keys %$args) {
        my ($arg) = split /[:=|]/;
        $arg = "-$arg" if length($arg) > 1;
        $arg = "-$arg" if $arg;
        printf("  %-15s %s\n", $arg, $args->{$_});
        }
    print "\n";
    exit(1);
    }

1;    # yipiness

__END__

=head1 NAME

cpan2rpm - A Perl module packager

=head1 SYNOPSIS

cpan2rpm [options] <module>

This script generates an RPM package from a Perl module.  It uses the standard RPM file structure and creates a spec file, a source RPM, and a binary, leaving these in their respective directories.

The script can operate on local files, urls and CPAN module names.  Install this package if you want to create RPMs out of Perl modules.

=head1 DESCRIPTION

The syntax for cpan2rpm requires a single module name, which can take one of three different forms: 1) a CPAN module name (e.g. XML::Simple), 2) a URL (both http:// and ftp:// style locators will work), and 3) a local filename reference to a tarball (e.g. /tmp/XML-Simple-1.05.tar.gz).  The module name may be preceded by a number of optional arguments which modify the behaviour of the script.

By default, the search.cpan.org website is "walked" to
determine the latest tarball for the specified module.
If an exact match is not found, the CPAN module is used
to determine and download the module.

If you have not configured CPAN (CPAN.pm or CPAN/MyConfig.pm)
you can configure it with the following:

perl -MCPAN -eshell

If the <module> passed is either a CPAN module name or a URL the script automatically does a download (when CPAN module names are specified, the latest distribution is used), putting it in the SOURCES directory.  If <module> is given as a local filename, the tarball gets copied to the SOURCES directory.  NOTE: at present the script will not handle .bz2 tarballs.

The spec file generated will generally assume header values as configured in the RPM macro files which are evaluated in the following order: F</usr/lib/rpm/macros>, F</etc/rpm/macros> and F<~/.rpmmacros>.  Most of these headers can, however, be overridden through options.  Whenever a header is neither configured in the RPM macro files nor is passed at the command line, the script will seek to calculate a proper value and supplies a default as stated for each option below.  It is thus typicall sufficient to provide only the <module> name.

The C<options> available are as follows:

=over 2

=item I<--pkgname=C<string-value>>

The RPM package name.  This is the C<Name> header in the RPM's spec file.  Please note that the string C<perl-> will be prepended to any value passed here.  If no value is supplied, the script will use the NAME field found in the module's Makefile.PL

=item I<--version=C<float-value>>

The script determines the version number of the module by parsing the tarball name.

=item I<--release=C<integer-value>>

The package release number. Defaults to 1.

=item I<--summary=C<string-value>>

A one-line description of the package.  If left unspecified the script will use the module name, appending an abstract whenever available.

=item I<--description=C<string-value>>

This text describes the package/module.  This value is picked up from the POD's Synopsis section in the module.  Defaults to "None.".

=item I<--url=C<string-value>>

The home url for the package.  Defaults to F<http://www.cpan.org>.

=item I<--group=C<string-value>>

This is the RPM group.  For further information on available groups please see your RPM documentation.  Defaults to C<Applications/CPAN>.

=item I<--author=C<string-value>>

This is the name and address of the person who authored the module.  Typically it should be in the format: I<Name <e-mail-addressE<gt>>.  If left unspecified, the script will attempt to extract it from the tarball's MakeMaker file, failing to build the package otherwise.  There is no default for this option.

=item I<--packager=C<string-value>>

This is you (if you're packaging someone else's module).  The string should be in the same format as for --author and defaults to: C<Arix International <cpan2rpm@arix.comE<gt>> unless the RPM macro files provide a value.

=item I<--license=C<string-value>>

The license header specified in the spec file.  This field is also sometimes referred to as I<Copyright>, but I<License> is a more suitable name and has become more common.  Defaults to C<Artistic>, Perl's own license.

=item I<--distribution=C<string-value>>

The script will use the %{distribution} tag defined in the RPM macros file.  If this tag is not set, the script will attempt to determine the distribution name by looking at the F</etc/issue> file.  If this file does not exist, the distribution will be left blank.

=item I<--buildarch=C<string-value>>

Allows specification of an architecture for building the RPM.
Currently defaults to whatever matches $Config{config_args}
=~ /-march=(\S+)/ from "use Config;".

=item I<--buildroot=C<string-value>>

Allows specifying a directory to use as a BuildRoot.  Don't mess with this is you don't know what it is.  Defaults to: C<%{_tmppath}/%{name}-%{version}>.

=item I<--provides=C<string-value>>

Indicates that a package should be provided by the module being built.  RPM will generate an appropriate list of provided dependencies and any passed here will be I<in addition> to those calculated.

=item I<--requires=C<string-value>>

Indicates packages that should be required for installation.  This option works precisely as --requires above.

=item I<--no-requires=C<string-value>>

Suppresses generation of a given required dependency.  Sometimes authors create dependencies on modules the packager can't find, sometimes RPM generates spurious dependencies.  This option allows the packager to arbitrarily supress a given requirement.  The value may be a comma-separated list.

=item I<--req-scan-all>

By default, the I<rpm-build> requirements script scans all files in a tarball for requirements information.  As this may on occasion generate requirements on the produced rpm that belong only to sample programs or other files not critical to the module being installed, we provide a patch the user may apply (included in this distribution as F<perl.req.patch>) which causes dependencies to be harvested from only F<.pm> files.  When this patch is installed, this switch reverses the behaviour, causing I<cpan2rpm> to scan all files as originall intended.

=item I<--spec-only>

This option instructs the script to not build the RPM package but instead to only display the generated spec file on stdout.

=item I<--make-maker=C<string-value>>

This option allows passing a string to the MakeMaker process (i.e. perl Makefile.PL <your-arguments-here>)

=item I<--make=C<string-value>>

Arguments supplied here get passed directly to the make process.

=item I<--make-no-test>

Use this option to suppress running a module's test suite during build.

=item I<--make-install=C<string-value>>

Allows user to supply arguments to the make install process.

=item I<--no-clean>

By default, the system passes I<--clean> to I<rpmbuild>, thus removing the unpacked sources from the BUILD directory.  This option suppresses that functionality.

=item I<--shadow-pure>

Forces installation under installarchlib even if the
module is pure perl.  This is significant because it
is first in the @INC search for module determination.
This will not do any good for modules with XS code
or those that are already installed into an
architecture dependent path.  This is most useful
for those pure perl modules that come stock with the
perl rpm itself (i.e. Test::Harness) but you wish
to try another version without having to be forced
to use "rpm --replacefiles" and destroying the old
files.  Using this option will allow both versions
of the module to be installed, but the new version
will just mask the old version later in the @INC.
Additionally, the new man pages will mask the old
man pages even though the man pages for both version
will be installed.  This option should only be used
as a last resort to install a module when "conflicts"
errors occur on rpm installation such as the following:

  file from install of perl-Module-1.11-1 conflicts with file from package perl-5.x.x

Use may be required to use --force (see below) in
conjuction with this option to build a fresh rpm
before attempting to --install again.

=item I<--patch=C<string-value>>

This option allows specifying patch files to be inserted into the spec file and applied when building the source.  Please note the option may be used multiple time to specify multiple patches.

=item I<--nopkgprfx>

Suppresses prefixing the package name with the string C<perl->.

=item I<--force>

By default the script will do as little work as possible i.e. if it has already previously retrieved a module from CPAN, it will not retrieve it again.  If it has already generated a spec file it will not generate it again.  This option allows the packager to force all actions, starting from scratch.

=item I<--install>

Install the RPM after building it.  If non-root user, you
must have "sudo rpm" privileges to use this option.

=item I<--debug[=n]>

This option produces debugging output.  An optional integer increases the level of verbosity for this output.  If no integer is given, 1 is assumed.

=item I<--help, -h>

Displays a terse syntax message.

=back

=head1 NOTES

This script requires that RPM be installed.  Both B<rpm> and B<rpm-build>
must be installed on the local machine.  Please see the RPM documentation (man rpm) for further information.

Additionally, the B<Perl> module will be needed :) and the CPAN module
(which is bundled with the Perl distribution) will need to be configured.
For further information please refer to the CPAN manpage.

=head1 TODO

For now, the list below is what's awaits my attention, but I'm happy to work on any feature requests you may have :)

1. should really have an /etc file + ~/.cpan2rpm

=head1 BUGS

Same goes for bugs.

=head1 AUTHOR

Erick Calder <ecalder@cpan.org>

=head1 ACKNOWLEDGEMENTS

The script was inspired by B<cpanflute> which is distributed with the rpm-build package from RedHat.  Many thanks to Robert Brown <bbb@cpan.org> for all his cool tricks, advice and patient support.

=head1 AVAILABILITY + SUPPORT

For help, comments or suggestions pleawe e-mail F<cpan2rpm@arix.com>.  To subscribe to an announcements mailing list address a blank message to the above address with subject header "subscribe" (or "unsubscribe" as need dictates).

The latest version of the tarball, RPM and SRPM may always be found at:

F<http://perl.arix.com/>

=head1 LICENCE AND COPYRIGHT

This utility is free and distributed under GPL, the Gnu Public License.

$Id: cpan2rpm,v 2.17 2002/12/17 21:07:45 ekkis Exp $

=cut
